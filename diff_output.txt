diff --git a/index.js b/index.js
index 42fdced..2902771 100644
--- a/index.js
+++ b/index.js
@@ -1667,7 +1667,7 @@ const stremioCommunityPrefetchTracker = new LRUCache({
 });
 
 /**
- * Detect if a request is from Stremio Community
+ * Detect if a request is from Stremio Community or its player (libmpv)
  * @param {Object} req - Express request object
  * @returns {boolean} - True if request is from Stremio Community
  */
@@ -1677,11 +1677,15 @@ function isStremioCommunityRequest(req) {
     const origin = (req.get('origin') || req.get('referer') || '').toLowerCase();
     const userAgent = (req.get('user-agent') || '').toLowerCase();
 
-    // Detect Stremio Community by origin (web version) or user-agent (desktop wrapper)
+    // Detect Stremio Community by:
+    // - Origin containing "zarg" (web version: https://stremio.zarg.me)
+    // - User-agent containing "stremioshell" (desktop app wrapper)
+    // - User-agent containing "libmpv" (the player that does prefetching, no origin)
     const isZargOrigin = origin.includes('zarg');
     const isStremioShell = userAgent.includes('stremioshell');
+    const isLibmpv = userAgent.includes('libmpv') && (!origin || origin === 'null' || origin === 'none');
 
-    return isZargOrigin || isStremioShell;
+    return isZargOrigin || isStremioShell || isLibmpv;
 }
 
 /**
@@ -1744,6 +1748,7 @@ function checkStremioCommunityPrefetchCooldown(configHash, req) {
         return { blocked: false, reason: 'non-libmpv request allowed', remainingMs };
     }
 
+    // libmpv prefetch during cooldown - block it
     return {
         blocked: true,
         reason: `prefetch cooldown (${remainingMs}ms remaining)`,
@@ -7524,13 +7529,13 @@ function generateTranslationSelectorPage(subtitles, videoId, targetLang, configS
 // Middleware to replace {{ADDON_URL}} placeholder in responses
 // This is CRITICAL because Stremio SDK uses res.end() not res.json()
 app.use('/addon/:config', (req, res, next) => {
-    // REQUEST TRACE: Log all incoming addon requests (helps diagnose "Stremio not sending requests" issues)
-    // This runs BEFORE any processing, so if this doesn't log, the request never reached the server
     const requestPath = req.path || req.url || 'unknown';
     const isSubtitlesRequest = requestPath.includes('/subtitles/');
     const isManifestRequest = requestPath.includes('/manifest.json');
     const isDownloadRequest = requestPath.includes('/subtitle/') || requestPath.includes('/translate/');
 
+    // REQUEST TRACE: Log all incoming addon requests (helps diagnose "Stremio not sending requests" issues)
+    // This runs BEFORE any processing, so if this doesn't log, the request never reached the server
     if (isSubtitlesRequest || isManifestRequest) {
         // Log subtitle and manifest requests at INFO level for visibility
         log.info(() => `[Addon Request] ${req.method} ${requestPath.substring(0, 100)} (UA: ${(req.get('user-agent') || 'none').substring(0, 50)})`);
diff --git a/src/utils/sessionManager.js b/src/utils/sessionManager.js
index 0388019..447f35d 100644
--- a/src/utils/sessionManager.js
+++ b/src/utils/sessionManager.js
@@ -1012,17 +1012,17 @@ class SessionManager extends EventEmitter {
             delete decryptedConfig.__decryptionWarningFields;
         }
 
-        // Skip fingerprint validation if decryption had warnings (encryption key mismatch)
+        // DISABLED: Fingerprint validation causes false positives when config schema changes
+        // (e.g., new fields added, encrypted values differ after decrypt cycle). Token validation
+        // is sufficient to detect cross-session contamination. Fingerprint mismatches are now
+        // logged at debug level for diagnostics only - sessions are NOT deleted.
         if (!hasDecryptionWarnings && metadata.fingerprint && metadata.fingerprint !== fingerprint) {
-            log.warn(() => `[SessionManager] Session fingerprint metadata mismatch for ${redactToken(token)} - deleting session`);
-            this.deleteSession(token);
-            return null;
+            log.debug(() => `[SessionManager] Fingerprint mismatch (metadata) for ${redactToken(token)} - stored=${metadata.fingerprint}, computed=${fingerprint}. Session preserved (fingerprint validation disabled).`);
+            // Don't delete - continue with session
         }
-        // Skip fingerprint validation if decryption had warnings (encryption key mismatch)
         if (!hasDecryptionWarnings && sessionData.fingerprint && fingerprint !== sessionData.fingerprint) {
-            log.warn(() => `[SessionManager] Fingerprint mismatch for ${redactToken(token)} - discarding contaminated session`);
-            this.deleteSession(token);
-            return null;
+            log.debug(() => `[SessionManager] Fingerprint mismatch (stored) for ${redactToken(token)} - stored=${sessionData.fingerprint}, computed=${fingerprint}. Session preserved (fingerprint validation disabled).`);
+            // Don't delete - continue with session
         }
         if (!sessionData.fingerprint) {
             sessionData.fingerprint = fingerprint;
@@ -1048,24 +1048,29 @@ class SessionManager extends EventEmitter {
             }
         }
 
-        // Defense-in-depth: ensure the stored integrity tag matches the token + fingerprint
-        const expectedIntegrity = computeIntegrityHash(token, sessionData.fingerprint || fingerprint);
-        if (sessionData.integrity && sessionData.integrity !== expectedIntegrity) {
-            log.warn(() => `[SessionManager] Integrity mismatch for ${redactToken(token)} - discarding contaminated session`);
-            this.deleteSession(token);
-            return null;
-        }
-        if (!sessionData.integrity) {
-            sessionData.integrity = expectedIntegrity;
-            this.cache.set(token, sessionData);
-            this.dirty = true;
-            this._trackPersistence(Promise.resolve().then(async () => {
-                const adapter = await getStorageAdapter();
-                const ttlSeconds = this._calculateTtlSeconds();
-                await adapter.set(token, sessionData, StorageAdapter.CACHE_TYPES.SESSION, ttlSeconds);
-            }).catch(err => {
-                log.error(() => ['[SessionManager] Failed to persist integrity backfill:', err?.message || String(err)]);
-            }));
+        // Defense-in-depth: ensure the stored integrity tag matches the token + stored fingerprint.
+        // IMPORTANT: Use stored fingerprint only (not recomputed) because recomputed fingerprint
+        // may differ due to schema changes. Integrity check still validates token binding.
+        if (sessionData.fingerprint) {
+            const expectedIntegrity = computeIntegrityHash(token, sessionData.fingerprint);
+            if (sessionData.integrity && sessionData.integrity !== expectedIntegrity) {
+                log.warn(() => `[SessionManager] Integrity mismatch for ${redactToken(token)} - discarding contaminated session`);
+                this.deleteSession(token);
+                return null;
+            }
+            // Backfill missing integrity using stored fingerprint
+            if (!sessionData.integrity) {
+                sessionData.integrity = expectedIntegrity;
+                this.cache.set(token, sessionData);
+                this.dirty = true;
+                this._trackPersistence(Promise.resolve().then(async () => {
+                    const adapter = await getStorageAdapter();
+                    const ttlSeconds = this._calculateTtlSeconds();
+                    await adapter.set(token, sessionData, StorageAdapter.CACHE_TYPES.SESSION, ttlSeconds);
+                }).catch(err => {
+                    log.error(() => ['[SessionManager] Failed to persist integrity backfill:', err?.message || String(err)]);
+                }));
+            }
         }
 
         // Backfill missing fingerprint for legacy sessions
@@ -1403,30 +1408,28 @@ class SessionManager extends EventEmitter {
                     return null;
                 }
 
-                // Skip fingerprint validation if decryption had warnings (encryption key mismatch)
+                // DISABLED: Fingerprint validation causes false positives when config schema changes
+                // (e.g., new fields added, encrypted values differ after decrypt cycle). Token validation
+                // is sufficient to detect cross-session contamination. Fingerprint mismatches are now
+                // logged at debug level for diagnostics only - sessions are NOT deleted.
                 if (!hasDecryptionWarnings && metadata?.fingerprint && metadata.fingerprint !== fingerprint) {
-                    log.warn(() => `[SessionManager] Session fingerprint metadata mismatch on storage load for ${redactToken(token)} - stored=${metadata.fingerprint}, computed=${fingerprint} - deleting session`);
-                    await deleteFromStorage();
-                    this.cache.delete(token);
-                    this.decryptedCache.delete(token);
-                    return null;
+                    log.debug(() => `[SessionManager] Fingerprint mismatch (metadata) on storage load for ${redactToken(token)} - stored=${metadata.fingerprint}, computed=${fingerprint}. Session preserved (fingerprint validation disabled).`);
+                    // Don't delete - continue with session
                 }
-
-                // Skip fingerprint validation if decryption had warnings (encryption key mismatch)
                 if (!hasDecryptionWarnings && stored.fingerprint && fingerprint !== stored.fingerprint) {
-                    log.warn(() => `[SessionManager] Fingerprint mismatch on storage load for ${redactToken(token)} - stored=${stored.fingerprint}, computed=${fingerprint} - removing corrupted session`);
-                    await deleteFromStorage();
-                    this.cache.delete(token);
-                    this.decryptedCache.delete(token);
-                    return null;
+                    log.debug(() => `[SessionManager] Fingerprint mismatch (stored) on storage load for ${redactToken(token)} - stored=${stored.fingerprint}, computed=${fingerprint}. Session preserved (fingerprint validation disabled).`);
+                    // Don't delete - continue with session
                 }
-                const expectedIntegrity = computeIntegrityHash(token, stored.fingerprint || fingerprint);
-                if (stored.integrity && stored.integrity !== expectedIntegrity) {
-                    log.warn(() => `[SessionManager] Integrity mismatch on storage load for ${redactToken(token)} - removing contaminated session`);
-                    await deleteFromStorage();
-                    this.cache.delete(token);
-                    this.decryptedCache.delete(token);
-                    return null;
+                // Integrity check uses stored fingerprint only (not recomputed) for backwards compatibility
+                if (stored.fingerprint && stored.integrity) {
+                    const expectedIntegrity = computeIntegrityHash(token, stored.fingerprint);
+                    if (stored.integrity !== expectedIntegrity) {
+                        log.warn(() => `[SessionManager] Integrity mismatch on storage load for ${redactToken(token)} - removing contaminated session`);
+                        await deleteFromStorage();
+                        this.cache.delete(token);
+                        this.decryptedCache.delete(token);
+                        return null;
+                    }
                 }
 
                 if (!stored.fingerprint) {
